**Análise do Script 1 de Inicialização do Robô NAO no CoppeliaSim**

O primeiro script do projeto foi desenvolvido em LUA e tem como objetivo principal modificar automaticamente as cores das partes visíveis do robô humanoide NAO dentro do ambiente de simulação CoppeliaSim. Essa mudança é realizada assim que a simulação é iniciada, garantindo uma aparência padronizada e fiel ao modelo real do robô, o que facilita a visualização e a identificação de cada um de seus componentes durante os testes.

Logo no início do código, o comando sim=require'sim' é responsável por importar a biblioteca principal do CoppeliaSim. Essa biblioteca fornece todas as funções necessárias para manipular objetos, propriedades e elementos visuais da cena. Em seguida, são definidas duas variáveis que armazenam as cores que serão aplicadas no robô: w={0.95,0.95,0.95} e g={1,0.5,0.08}. A primeira representa um tom de branco levemente suavizado, e a segunda define um tom alaranjado. Essas cores correspondem às características visuais típicas do robô NAO, que combina o branco predominante com detalhes coloridos.

Depois disso, o script cria duas listas: allObjectsToExplore e allVisibleShapes. A primeira é inicializada com o comando sim.getObject('..'), que obtém o objeto pai do script — ou seja, o modelo principal do robô NAO. Já a segunda lista (allVisibleShapes) é inicialmente vazia e servirá para armazenar todos os objetos tridimensionais (shapes) que o código irá encontrar e modificar.

Em seguida, o programa entra em um laço de repetição que percorre todos os objetos pertencentes ao modelo do robô. Esse processo é importante porque o NAO é composto por várias partes — cabeça, tronco, braços, pernas, entre outras —, e cada uma delas é tratada separadamente dentro da simulação. Assim, o laço garante que nenhuma parte fique de fora da análise.

Dentro desse laço, o comando sim.getObjectType(obj) verifica se o objeto em questão é um shape (isto é, um elemento visível da cena). Caso seja, o script consulta suas propriedades com sim.getIntProperty(obj, 'layer'), que retorna o número da camada em que o objeto está localizado. No CoppeliaSim, as camadas (layers) determinam a visibilidade de cada objeto — apenas as camadas iniciais (valores abaixo de 256) são exibidas por padrão. Dessa forma, o código filtra e seleciona apenas os elementos visíveis do robô, ignorando os que estão ocultos ou desativados.

Além disso, o script verifica também os objetos filhos de cada componente, utilizando a função sim.getObjectChild(obj, index). Essa busca é feita dentro de um laço que continua até não haver mais filhos (quando o valor retornado é -1). Esse processo de varredura garante que todas as partes do robô — inclusive as menores ou hierarquicamente internas — sejam incluídas na lista de objetos a serem modificados. Assim, a mudança de cor é aplicada de forma completa e uniforme em todo o modelo.

Por fim, o código entra na etapa de aplicação das cores. A função sim.setShapeColor() é utilizada para alterar as propriedades visuais dos shapes identificados. Essa função recebe quatro parâmetros: o objeto, o nome do material (como “NAO_WHITE” ou “NAO_GREY”), o tipo de componente (no caso, 0, que representa a superfície principal) e o vetor RGB da cor desejada. Com isso, o script aplica tanto o tom branco quanto o alaranjado em diferentes partes do robô, reproduzindo o padrão visual característico do NAO físico.

Em síntese, esse script tem um papel fundamental na personalização e identificação visual do robô NAO dentro do CoppeliaSim. Ele automatiza a busca e a modificação das cores de cada componente, tornando o modelo mais realista, organizado e de fácil visualização durante as simulações.

Do ponto de vista acadêmico, o código demonstra de forma prática como a linguagem LUA pode ser usada para manipular objetos tridimensionais em ambientes de simulação robótica. Além disso, exemplifica conceitos essenciais, como hierarquia de objetos, camadas de visibilidade e alteração de propriedades visuais, mostrando a importância de scripts automatizados para a configuração eficiente de modelos robóticos complexos em ambientes virtuais.
